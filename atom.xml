<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://gavintang.me</id>
    <title>Gavin Tang`s blog</title>
    <updated>2021-04-02T05:25:54.945Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://gavintang.me"/>
    <link rel="self" href="https://gavintang.me/atom.xml"/>
    <subtitle>Program, algorithm and cool tech</subtitle>
    <logo>https://gavintang.me/images/avatar.png</logo>
    <icon>https://gavintang.me/favicon.ico</icon>
    <rights>All rights reserved 2021, Gavin Tang`s blog</rights>
    <entry>
        <title type="html"><![CDATA[递归（Recursion）]]></title>
        <id>https://gavintang.me/recursion/</id>
        <link href="https://gavintang.me/recursion/">
        </link>
        <updated>2018-10-31T03:14:37.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="什么是递归">什么是递归</h3>
<p>递归（Recursion）是一种解决问题的方法或编程技巧，将问题分解为更小的子问题，直到得到一个足够小的问题可以被简单的解决；通常递归涉及函数的自身调用，递归允许我们编写优雅的解决方案，解决可能很难编程的问题。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="什么是递归">什么是递归</h3>
<p>递归（Recursion）是一种解决问题的方法或编程技巧，将问题分解为更小的子问题，直到得到一个足够小的问题可以被简单的解决；通常递归涉及函数的自身调用，递归允许我们编写优雅的解决方案，解决可能很难编程的问题。</p>
<!-- more -->
<h3 id="递归的三定律">递归的三定律</h3>
<ul>
<li><strong>可分解成子问题</strong> 递归的逻辑是能够将问题分解成数据规模更小和更容易的问题来解决的优雅表达，子问题就是数据规模更小的问题。比如「前n项有序数列求和」的问题，可以分解为求解「前n-1项有序数列求和」这样一个子问题。</li>
<li><strong>子问题求解思路一致</strong> 问题与分解的子问题之间，除了数据规模不同，所有子问题的求解思路一致，如求解「前n项有序数列求和」的思路，和「前n-1项有序数列求和」的思路，是一模一样的。</li>
<li><strong>终止条件</strong> 递归必须具有基本情况，通常是足够小可以直接求解的问题，递归算法必须改变其状态并向基本情况靠近，如「前n项有序数列求和」的例子是 f(1) = 1，这就是递归的终止条件。</li>
</ul>
<h3 id="递推公式">递推公式</h3>
<p>写代码之前的关键是找到将大问题分解为小问题的规律，并基于此找到递推公式和终止条件，最终转化成递归代码。</p>
<pre><code class="language-go">// 有序数列求和 1+2+3+4+...+100
// 递推公式 sum(n) = sum(n - 1) + n
// 终止条件 f(1) = 1
func sum(n int) int {
    if n == 1 {
        return 1
    } else {
        return sum(n-1) + n
    }
}
</code></pre>
<h3 id="经验技巧">经验&amp;技巧</h3>
<ul>
<li>防止递归堆栈溢出。</li>
<li>避免重复子问题计算。</li>
<li>递归代码调试(打印日志、设置条件断点)。</li>
<li>权衡有无必要改写成非递归代码。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组（Array）]]></title>
        <id>https://gavintang.me/array/</id>
        <link href="https://gavintang.me/array/">
        </link>
        <updated>2018-10-10T12:56:02.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="什么是数组">什么是数组</h3>
<p>数组（Array）在逻辑上是一种线性表数据结构，在物理上是顺序存储结构，它用一组「连续的内存空间」存储一组具有「类型相同」的数据；正因为这两个约束使得数组具备随机访问的特性，但同时要想在数组中插入或删除数据，为了保证连续性，就需要做大量的数据搬移工作。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="什么是数组">什么是数组</h3>
<p>数组（Array）在逻辑上是一种线性表数据结构，在物理上是顺序存储结构，它用一组「连续的内存空间」存储一组具有「类型相同」的数据；正因为这两个约束使得数组具备随机访问的特性，但同时要想在数组中插入或删除数据，为了保证连续性，就需要做大量的数据搬移工作。</p>
<!-- more -->
<h3 id="线性表">线性表</h3>
<p>提到线性表（Linear List），除了数组，链表、队列以及栈等也是线性表数据结构，线性表就是数据排成像一条线一样的数据结构，每个线性表上除首尾节点外最多只有一个前驱节点和后继节点，具有「一对一」的关系，存储上分为顺序存储结构和链式存储结构。</p>
<figure data-type="image" tabindex="1"><img src="https://gavintang.me/post-images/1611481007613.jpg" alt="linear" loading="lazy"></figure>
<p>与线性表相反的概念是非线性表，如树结构和图结构等，之所以非线性，是因为在非线性表中的数据之间并不是前后的关系，即非「一对一」的关系。</p>
<figure data-type="image" tabindex="2"><img src="https://gavintang.me/post-images/1611481053817.jpg" alt="nolinear" loading="lazy"></figure>
<h3 id="随机访问">随机访问</h3>
<p>数组通过下标随机访问数组内元素，例如一个长度为 10 的 数组 int32 a[10] = {0}，计算机给数组 a[10] 分配了一块连续内存空间 1000～1039，这里内存块的首地址 base_address = 1000，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据，当计算机需要随机访问数组中某个元素时，通过以下寻址公式计算：</p>
<pre><code class="language-c">a[i]_address = base_address + i * type_size // type_size 为数组的每个元素的大小(int32为4字节)
</code></pre>
<h4 id="为何下标从0开始">为何下标从0开始</h4>
<p>从数组存储的内存模型上来看，「下标」最确切的定义应该是「偏移（offset）」。如果用 a 表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址公式为：</p>
<pre><code>a[k]_address = base_address + k * type_size
</code></pre>
<p>如果数组从 1 开始计数，数组元素 a[k] 的内存地址公式为：</p>
<pre><code>a[k]_address = base_address + (k-1) * type_size
</code></pre>
<p>对比两个公式，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p>
<h4 id="数组越界访问">数组越界访问</h4>
<p>数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。</p>
<h3 id="插入与删除">插入与删除</h3>
<p>前面概念中提到，数组为了保持内存数据的连续性，会导致插入或删除需要做大量的数据搬移工作，因此变得比较低效。</p>
<p>假设数组的长度为 n，如果需要将一个数据插入到数组中的第 k 个位置，为了把第 k 个位置腾出来给新来的数据，需要将第 k～n 这部分元素都顺序地往后挪一位。如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+...n)/n=O(n)。</p>
<p>如果数组中的数据是有序的，在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，可以直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。</p>
<p>利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)，这种处理思想在快排中也会用到。</p>
<p>删除也类似，可以采用标记法，当空间不足时触发一次性删除操作。</p>
<h3 id="数组与链表区别">数组与链表区别</h3>
<ul>
<li>数组用一段连续的内存空间存储一组类型相同的数据并支持随机访问，根据下标随机访问的时间复杂度为 O(1)，插入和删除操作需搬运大量数据。</li>
<li>而链表则相反，内存空间不连续且不支持随机访问，链表的插入和删除操作无需搬运数据，时间复杂度 O(1)。</li>
</ul>
<h3 id="总结">总结</h3>
<p>数组是最基础、最简单的数据结构了，数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。但如果是底层开发，使用数组可能会比高级语言提供的容器类更合适。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法复杂度分析]]></title>
        <id>https://gavintang.me/algorithm-complexity/</id>
        <link href="https://gavintang.me/algorithm-complexity/">
        </link>
        <updated>2018-10-05T03:34:16.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="为什么需要复杂度分析">为什么需要复杂度分析？</h3>
<p>通过统计、监控，就能得到算法执行时间和占用的内存大小，但测试结果非常依赖测试环境，测试结果受数据规模与有序度的影响较大；所以需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法，这就是算法复杂度分析。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="为什么需要复杂度分析">为什么需要复杂度分析？</h3>
<p>通过统计、监控，就能得到算法执行时间和占用的内存大小，但测试结果非常依赖测试环境，测试结果受数据规模与有序度的影响较大；所以需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法，这就是算法复杂度分析。</p>
<!-- more -->
<h3 id="算法复杂度">算法复杂度</h3>
<p>一个算法有多好、多快，怎么衡量一个算法的好坏？计算机科学在算法分析过程中提出了算法复杂度理论，这套理论可以量化算法的效率，以此作为标准来衡量到底选择哪一种算法；复杂度有两个维度，分别为时间和空间。</p>
<p>一个实现了某算法的程序：</p>
<ul>
<li>如果计算的速度越快，那么这个算法时间复杂度越低。</li>
<li>如果占用的计算资源越少，那么空间复杂度越低。</li>
<li>要选择复杂度低的算法，衡量好空间和时间的消耗，选出适合特定场景的算法。<br>
这两个复杂度维度的量化过程都是一样的，所以后面只分析时间复杂度。</li>
</ul>
<p>算法执行时间用 T(n) 表示，如每行代码执行总次数用 f(n) 表示，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n) 是 T(n) 的同数量级函数，记作 T(n) = O(f(n))；O表示代码的执行时间 T(n) 与 f(n) 表达式成正比，表达代码的执行时间随数据规模增长的变化趋势，所以也称 O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。</p>
<h3 id="渐进符号">渐进符号</h3>
<p>如何量化复杂度，到底有多复杂？计算机科学其实抽象出了几个复杂度渐进符号：O(Omicron)、ο(omicron)、Θ(Theta)、Ω(Omega) 以及 ω(omega)；下面着重介绍一下 O(Omicron)，我们习惯读作大O。</p>
<p>假设算法的运行时间表达式为 T(n)= 3 * n^2 + 4 * n^3，如果问题规模 n 足够大，那么低次方的项将无足轻重，运行时间主要取决于高次方项 4 * n^3，随着 n 的增大，4 * n^3 中的常数项 4 也变得不重要了，所以算法的运行时间 T(n) 约等于 n^3，记为 T(n) = O(n^3)。</p>
<p>例如 f(n) = 2n^2 + 1，则时间复杂度 T(n) = O(2n^2+1)，通常会忽略「低阶、常量、系数」，因为当 n 很大时并不影响增长趋势，最终写成 T(n) = O(n^2)。</p>
<p>大O 的数学含义：<br>
设 f(n) 和 g(n) 是定义域 n 为自然数集合的函数， f(n) 函数的阶不高于 g(n) 函数的阶；也可以说，存在正常量 c 和 n0，对于所有 n &gt;= n0，有 0 &lt;= f(n) &lt;= c * g(n)，那么可以记为 f(n) = O(g(n))，g(n) 是 f(n) 的渐进上界。</p>
<p>下图展示了几种符号的函数形式：</p>
<figure data-type="image" tabindex="1"><img src="https://gavintang.me/post-images/1609314368128.jpg" alt="complexity" loading="lazy"></figure>
<p>当 n 为某个值时：</p>
<ul>
<li>如果 f(n) 被 g(n) 两条线夹在中间，那么 g(n) 就是渐进紧确界。</li>
<li>如果 g(n) 的线在上面，就是渐进上界。</li>
<li>如果 g(n) 线在下面，就是渐进下界。</li>
</ul>
<p>我们一般会评估一个算法的渐进上界O，因为这表示算法的最坏情况。</p>
<h3 id="时间复杂度分析技巧">时间复杂度分析技巧</h3>
<ul>
<li>只关注循环执行次数最多的一段代码。</li>
<li>加法法则，总复杂度等于量级最大的那段代码的复杂度。</li>
<li>乘法法则，嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。</li>
</ul>
<h3 id="最好-最坏与平均复杂度">最好、最坏与平均复杂度</h3>
<ul>
<li>最好时间复杂度是指在最理想的情况下执行代码的时间复杂度。</li>
<li>最坏时间复杂度是指在最糟糕的情况下执行代码的时间复杂度。</li>
<li>平均时间复杂度可以通过计算加权平均值（也叫期望值）得出，所以平均时间复杂度也叫加权平均时间复杂度或期望时间复杂度。</li>
</ul>
<h3 id="均摊时间复杂度">均摊时间复杂度</h3>
<p>通过摊还分析法（或者叫平摊分析）来分析均摊时间复杂度，其实可以认为一种特殊的平均时间复杂度。<br>
在多数情况下使用一个复杂度表示即可（比如最坏时间复杂度），只有在同一块代码的不同情况下，时间复杂度有量级的差距，才会使用最好、最坏、平均三种复杂度表示法来区分，而均摊复杂度应用的场景更加有限。</p>
<p>另外，平均时间复杂度对不同操作出现的概率不同进行加权平均，不强调操作的次序问题；而均摊时间复杂度针对操作的某个次序来求得总的时间复杂度，再均摊到各个操作步骤。故平均时间复杂度没有涉及到操作次序，而均摊时间复杂度涉及到，所以在一些合适的场景下，均摊时间复杂度对数据结构操作复杂度的估计具有更加的真实性。</p>
<h3 id="案例分析">案例分析</h3>
<pre><code class="language-c">// 全局变量，大小为 10 的数组 array，长度 len，下标 i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i &gt;= len) { // 数组空间不够了
     // 重新申请一个 2 倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来 array 数组中的数据依次 copy 到 new_array
     for (int j = 0; j &lt; len; ++j) {
       new_array[j] = array[j];
     }
     // new_array 复制给 array，array 现在大小就是 2 倍 len 了
     array = new_array;
     len = 2 * len;
   }
   // 将 element 放到下标为 i 的位置，下标 i 加一
   array[i] = element;
   ++i;
}
</code></pre>
<p>当 i &lt; len 时，即 i = 0, 1, 2, ..., n-1 的时候，for循环不执行，所以 n 次的时间复杂度都是 O(1)；<br>
当 i &gt;= len时，即 i = n 的时候，for循环进行数组的copy，所以只有这1次的时间复杂度是 O(n)；<br>
由此可知：</p>
<ul>
<li>该算法的最好情况时间复杂度为 O(1)；</li>
<li>最坏情况时间复杂度为 O(n)；</li>
<li>平均情况时间复杂度：
<ul>
<li>第一种计算方式为 (1+1+...+1+n)/(n+1) = 2n/(n+1)，所以平均复杂度为 O(1)；</li>
<li>第二种计算方式（加权平均法又称期望），1*(1/n+1)+1*(1/n+1)+...+1*(1/n+1)+n*(1/(n+1))=1，所以加权平均时间复杂度为 O(1)；</li>
<li>第三种计算方式（均摊时间复杂度），前 n 个操作复杂度都是 O(1)，第 n+1 次操作的复杂度是 O(n)，所以把最后一次的复杂度分摊到前 n 次上，那么均摊下来每次操作的复杂度为 O(1)。</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构与算法介绍]]></title>
        <id>https://gavintang.me/data-structure-and-algorithm-Introduction/</id>
        <link href="https://gavintang.me/data-structure-and-algorithm-Introduction/">
        </link>
        <updated>2018-09-29T08:55:09.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>通过学习 <a href="https://time.geekbang.org/column/intro/126">数据结构与算法之美</a> 专栏、相关书籍以及资料后形成本系列的 <a href="/tag/GU4uZdQGs/">#数据结构与算法</a> 学习笔记。</p>
</blockquote>
<h3 id="为什么要学习数据结构与算法">为什么要学习数据结构与算法？</h3>
<p>建立时间和空间复杂度意识，写出高质量的代码，能够设计基础架构，提升编程技能，训练逻辑思维，积攒人生经验，以此获得工作回报，实现你的价值，完善你的人生。</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>通过学习 <a href="https://time.geekbang.org/column/intro/126">数据结构与算法之美</a> 专栏、相关书籍以及资料后形成本系列的 <a href="/tag/GU4uZdQGs/">#数据结构与算法</a> 学习笔记。</p>
</blockquote>
<h3 id="为什么要学习数据结构与算法">为什么要学习数据结构与算法？</h3>
<p>建立时间和空间复杂度意识，写出高质量的代码，能够设计基础架构，提升编程技能，训练逻辑思维，积攒人生经验，以此获得工作回报，实现你的价值，完善你的人生。</p>
<!-- more -->
<p>所以，不管你是业务开发工程师，还是基础架构工程师；不管你是初入职场的初级工程师，还是工作多年的资深架构师，又或者是想转人工智能这些热门领域的程序员，数据结构与算法作为计算机的基础知识、核心知识，都是必须要掌握的。</p>
<p>掌握了数据结构与算法，看待问题的深度，解决问题的角度就会完全不一样。就像是站在巨人的肩膀上，拿着生存利器行走世界。数据结构与算法，会为你的编程之路，甚至人生之路打开一扇通往新世界的大门。</p>
<h3 id="什么是数据结构与算法">什么是数据结构与算法？</h3>
<p>从广义上讲，数据结构是指一组数据的存储结构，算法是指操作数据的一组方法；从狭义上讲，是指某些著名的经典数据结构与算法，比如队列、栈、堆、二分查找、动态规划等。</p>
<p>从大的方面来说，数据结构是反应数据的一种形式，分为逻辑结构和物理结构：</p>
<ul>
<li>逻辑结构，它是表现数据之间一种关系的结构，分为线性结构和非线性结构。</li>
<li>物理结构，它是表现数据是如何存储的，计算机内部是如何安排该数据的存储，通常分为顺序存储结构、链式存储结构、索引存储结构以及哈希存储结构。</li>
</ul>
<h3 id="数据结构与算法的关系">数据结构与算法的关系</h3>
<p>数据结构为算法服务，算法要作用于特定的数据结构之上；数据结构与算法是相辅相成的，因此无法孤立数据结构来单独讲算法。</p>
<h3 id="学习重点">学习重点</h3>
<p>复杂度分析要吃透，它是数据结构与算法的精髓；学习重点应放在最常用、最重要的数据结构与算法，总结如下：</p>
<ul>
<li>10个数据结构分别为数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树。</li>
<li>10个算法分别为递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配。</li>
</ul>
<h3 id="学习技巧">学习技巧</h3>
<p>遇到「困难」尝试反复迭代学习并不断沉淀，代码实现一遍、适度刷题巩固知识点；多思考并记笔记或博客与他人分享互动。</p>
<h3 id="知识图谱">知识图谱</h3>
<figure data-type="image" tabindex="1"><img src="https://gavintang.me/post-images/1609233039708.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>